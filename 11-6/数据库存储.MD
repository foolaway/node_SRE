## 存储

​		

​			Mysql用各种不同的存储技术，将数据存储到文件或内存中。数据库存储引擎是数据库的底层的软件组件，数据库可以使用数据存储引擎进行创建，查询，更新和删除数据的操作。不同的存储引擎会提供不同的存储机制，索引技巧，锁定水平等功能，现在许多的数据库管理系统都支持多种的不同的存储引擎。

​		

​		MySQL内的存储引擎，他有许多的存储引擎，但是使用的比较多的还是InnoDB，MyISAM，Memory这三个

InnoDB的最大特色就是支持了ACID兼容的事务（Transaction）功能，类似于PostgreSQL。

​		PostgreSQL 是一个免费的对象-关系数据库服务器(ORDBMS)，在灵活的BSD许可证下发行。

​		SQLlist工具是我们手机上的数据库，存放联系人、通话记录之类的，使用的也是SQL语言。



(show engines;)









### [MySQL中的page页](https://blog.csdn.net/weixin_26786277/article/details/113121272?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-113121272-blog-113870642.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-113121272-blog-113870642.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=1)



**一、表空间(table space)**     在 InnoDB 中存在两种表空间的类型：共享表空间和独立表空间。本质上是一个由一个或多个磁盘文件组成的虚拟文件系统。InnoDB用表空间并不只是存储表和索引，还保存了回滚段、双写缓冲区等。

**二、段(segment)**     段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。当我们创建数据表、索引的时候，就会相应创建对应的段，比如创建一张表时会创建一个表段，创建一个索引时会创建一个索引段。

**三、区(extent)**    在 InnoDB 存储引擎中，一个区会分配 64 个连续的页，一个区的大小是 64*16KB=1MB。在任何情况下每个区大小都为1MB，为了保证页的连续性，InnoDB存储引擎每次从磁盘一次申请4-5个区

**四、页(Page)**    页是InnoDB存储引擎磁盘管理的最小单位，每个页默认16KB；InnoDB存储引擎从1.2.x版本碍事，可以通过参数innodb_page_size将页的大小设置为4K、8K、16K。若设置完成，则所有表中页的大小都为innodb_page_size，不可以再次对其进行修改，除非通过mysqldump导入和导出操作来产生新的库。

**五、行(row)**     InnoDB存储引擎是按行进行存放的，每个页存放的行记录也是有硬性定义的，最多允许存放16KB/2-200，即7992行记录。

![image-20221109185938589](https://foolaway-bucker.oss-cn-hangzhou.aliyuncs.com/img/image-20221109185938589.png)

![image-20221109191302521](https://foolaway-bucker.oss-cn-hangzhou.aliyuncs.com/img/image-20221109191302521.png)









#####################################

### [mysql数据库怎么存储数据的](https://blog.csdn.net/agonie201218/article/details/125780653)

！！！！！！！

#### MySql中数据在磁盘

数据在磁盘中的存储在物理空间上面是连续的
数据是被存放在MySql设计出来的数据页上面的，数据页上面存储的才是最终的一行一行的记录
行的存储格式默认是Compact
每一行数据都会有相应的行描述部分，描述部分有【变长字段列表】【NULL标志位】【记录头信息】
每一行都会有next_record指针，指向记录头和变长字段列表的中间某个位置，方便寻址










### [数据库存储](https://blog.csdn.net/yyy_3y/article/details/123257598)



一个页一般会被分为两个部分：header 和 data。Header会存储一些关于这个页的元数据（页大小，Checksum，DBMS版本，事务可见性，压缩信息），Data区则用于真正存储信息



data区域的存储方法一般有两种：

- Tuple-oriented：最常用
- Log-structured

**Tuple-oriented**



![img](https://foolaway-bucker.oss-cn-hangzhou.aliyuncs.com/img/v2-796906de770a7f936af18164d935cd8a_720w.webp)



slot array 可以记录对应元组的大小、开始位置的offset等信息，header可以记录未使用的slot编号和最后一个slot的起始位置偏移量。slot array可以向后生长，tuple区域可以向前生长。这样的布局可以处理不同长度的data信息





# mmap

  一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的[地址空间](https://so.csdn.net/so/search?q=地址空间&spm=1001.2101.3001.7020)，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。

![在这里插入图片描述](https://foolaway-bucker.oss-cn-hangzhou.aliyuncs.com/img/20200702115043184.png)

 







#### n-ary 存储模型（N-Ary Storage Model NSM）

以行（Row）的形式展示的 tuple，这被称为 n-ary 存储模型。
基本思路是，讲单个 tuple 中的所有属性取出，并将它们连续地存储在 page 中。
一个 OLTP 的想法，因为要去访问的数据量在粒度上要足够的小，即一次取一行数据，而这一行数据会按照定义连续存储，这样就能访问到单个实体，拿到对应的信息。如果它是一行数据，就会非常高效，因为只需要跳到那个 page，找到那个数据就完事了。

优势：
1） 访问整个 tuple 时，插入/更新/删除数据都很快
2） 利于查询整个 tuple 的属性
劣势：
但如果要进行一些分析型的查询以及做些 OLAP 的工作，并且要去扫描整张表大部分的内容时，it will suck。因为这需要往内存塞一大堆不需要的数据。





### MySQL数据空洞

当对一条数据执行`delete`操作时，MySQL将数据删除后，并未将数据占用的空间返还给操作系统，而是将当前空间标记为"可复用"，当有新的数据插入时，则不会重新申请空间，而是插入到"可复用"空间中，这种"可复用"空间，称之为数据空洞







#### [结构化日志](https://my.oschina.net/hgfdoing/blog/3193451)

**结构化日志存储系统的基本组织是日志**，即 --- 仅追加的数据条目序列。每当有新数据要写入时，只需在日志末尾追加即可，而不是在磁盘上查找位置。通过对元数据（metadata）以相同方式处理，可以对数据建立索引：**元数据更新也将追加到日志中**。这看似效率低下，但**基于磁盘的索引结构（例如 B 树）通常非常宽泛，因此每次写入时我们需要更新的索引节点的数量通常很小**















#### 行式数据库：

１．数据是按行存储的
２．没有建立索引的查询将消耗很大的io
３．建立索引和视图需要花费一定的物理空间和时间资源
４．面对大量的查询,复杂的查询,数据库必须被大量膨胀才能满足性能需求

#### 列式数据库：

１．数据是按列存储的,每一列单独存放
２．数据既是索引
３．只访问查询涉及的列,大量降低系统io
４．每一列有一个线索来处理,支持查询的高并发
５．数据类型一致,数据特征相似,高效的压缩



为什么可以大量降低系统io:
比如查询表中所有人的名字;行式数据库需要查询所有行,列式数据库只需要查询name列.
行式与列式数据库优缺点:
根据实际的业务场景来选择对应的数据库系统.传统的crud操作应用适合行式数据库(表之间有关联关系);列式数据库适用于数据仓库,数据分析,海量存储,涉及到不经常更新的数据库,列式在并行查询,压缩上更有优势

列式存储数据库有：1.HBase；2.ClickHouse；3.Druid；4.HP Vertica（也支持行式存储）。







######################################



Linux内核由于存在page cache, 一般修改的文件数据并不会马上同步到磁盘，会缓存在[内存](https://so.csdn.net/so/search?q=内存&spm=1001.2101.3001.7020)的page cache中，我们把这种和磁盘数据不一致的页称为脏页，脏页会在合适的时机同步到磁盘。为了回写page cache中的脏页，需要标记页为**脏（dirty）**。



