# [缓冲池](https://blog.csdn.net/wuhenyouyuyouyu/article/details/93377605?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-93377605-blog-124468345.pc_relevant_default&spm=1001.2101.3001.4242.1&utm_relevant_index=3)



### 缓冲池存在的意义

  数据库的所有数据都是存储在磁盘中，磁盘I/O的效率是十分慢的，而我们每次查询数据却是很快，这是因为缓冲池的存在，缓冲池会把数据缓存到内存中，这样对数据操作效率就快了。
  以MySQL默认存储引擎InnoDB为例，InnoDB存储引擎是以数据页为单位来管理存储空间的，当我们对MySQL数据库进行增删改查等操作时，其本质都是在访问操作数据页，如读页，写页，新建页等。因此数据库管理系统DBMS会把需要的页数据加载到内存中，然后才可以操作数据页。



### 缓存原则

  缓冲池是将数据缓存到内存中，内存是有大小限制的，MySQL缓冲池具体的大小支持设置，我们不可以把所有数据都缓存到内存中，因此缓存数据是有优先级的，MySQL缓冲池缓存机制是遵循LRU淘汰机制(即最近最少使用被淘汰)，MySQL在LRU基础上做了冷热数据的分离，使得缓存更加高效。



### 数据的同步，一致性问题

  前面说过，所有的数据操作都是DBMS先将数据加载到缓冲池中，我们再对缓冲池中的数据页进行操作，当我们进行增删改操作时，数据只是修改了缓存中的信息，实际磁盘中的并没有修改，这就存在数据一致性的问题，MySQL针对这里的数据同步有自己的机制去刷新缓存与磁盘的数据，包括数据的事务处理等，最终让数据保持一直性。

### 缓冲池数量

  MySQL默认是一个缓冲池，在多线程的情景下，访问缓冲池是需要加锁处理的，当大量多线程并发时一个缓冲池的效率会很低，这时可以设置多个缓冲池，提高并发效率，注意当缓存池大小低于1G时，设置缓冲池个数无效，DBMS管理缓冲池也是需要性能开销的，所以不是缓冲池越多越好，适量最好



（1）缓冲池(buffer pool)是一种**常见的降低磁盘访问的机制；**

（2）缓冲池通常**以页(page)为单位缓存数据；**

（3）缓冲池的**常见管理算法是LRU**，memcache，OS，InnoDB都使用了这种算法；

（4）InnoDB对普通LRU进行了优化：

- 将缓冲池分为**老生代和新生代**，入缓冲池的页，优先进入老生代，页被访问，才进入新生代，以解决预读失效的问题
- 页被访问，且在老生代**停留时间超过配置阈值**的，才进入新生代，以解决批量数据访问，大量热数据淘汰的问题



![image-20220210221018824](https://foolaway-bucker.oss-cn-hangzhou.aliyuncs.com/img/1540879-20220623173330409-2053206449.png)





### [穿透型缓存与旁路型缓存，缓存穿透，雪崩与击穿](https://ld246.com/article/1604111988289)





## lock与latch区别

lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。此外，lock，正如在大多数数据库中一样，是有死锁机制的。下图显示lock与latch的区别

latch一般称为闩锁（轻量级锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差。在InnoDB存储引擎中，latch又分为mutex（互斥锁）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。







#### [缓冲池(Buffer Pool) 的设计原理和管理机制](https://blog.csdn.net/weixin_42157541/article/details/115919019?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-115919019-blog-124468345.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-115919019-blog-124468345.pc_relevant_default&utm_relevant_index=5)





## Flush 链表记录脏缓存页

1、脏页和脏数据

我们都知道 SQL 的增删改查都在 `Buffer Pool` 中执行，慢慢地，`Buffer Pool` 中的缓存页因为不断被修改而导致和磁盘文件中的数据不一致了，也就是 `Buffer Pool` 中会有很多个脏页，脏页里面很多脏数据。

所以，MySQL 会有一条后台线程，定时地将 `Buffer Pool` 中的脏页刷回到磁盘文件中。

但是，后台线程怎么知道哪些缓存页是脏页呢，不可能将全部的缓存页都往磁盘中刷吧，这会导致 MySQL 暂停一段时间。

2、MySQL 是怎么判断脏页的

我们引入一个和 free 链表类似的 flush 链表。他的本质也是通过缓存页的描述数据块中的两个指针，让修改过的缓存页的描述数据块能串成一个双向链表，这两指针大家可以认为是 flush_pre 指针和 flush_next 指针。



## LRU 链表记录缓存页的命中率

1、缓存命中率

我们都知道，当加载磁盘中的数据页到缓存中时，会从 free 链表找到空闲的缓存页，然后将数据加载到缓存页里。

但是缓存页总会有用完的时候，此时需要淘汰一下缓存页，将它刷入磁盘中，然后清空。

**那么会选择谁淘汰呢？**

那么必定会淘汰缓存命中率低的缓存页。

什么叫缓存命中率低：假如你有100次请求，有30次请求都是查询和修改缓存页一，直接操作缓存而不需要从磁盘加载，这就是缓存命中率高。而缓存页二自加载到 `Buffer Pool` 后，只被查询和修改过一次，之后的100次请求中甚至没有一次是查询和修改它的，这就是缓存命中率低了，因为大部分请求都是操作其他缓存页，甚至要从磁盘中加载。

2、lru 链表的使用原理

InnoDB 存储引擎是利用 lru 链表完成上面的缓存命中率的。lru 就是 Least Recently Used，最近最少使用的意思。

ps：lru 链表也是类似于 free 链表和 flush 链表的数据结构。

当有磁盘数据页加载数据到缓存页时，会将缓存页对应的描述数据块放入 lru 链表的头部；后续只要查询或者修改了缓存页的数据，也会将对应描述数据块移到 **lru 链表的头部**去。

此时，**lru 链表尾部**的描述数据块对应的缓存页，必定是命中率最低的，也就是使用最少的缓存页，所以优先被淘汰的肯定是它。

3、lru 链表存在的问题

lru 链表的使用当然不会像上面的那么简单。

因为 MySQL 为了提高性能，提供了一个机制：**预读机制**。

当你从磁盘上加载一个数据页的时候，他可能会连带着把这个数据页相邻的其他数据页，也加载到缓存里去。这个机制会带来这么一个问题：连带的数据页可能在后面的查询或者修改中，并不会用到，但是它们却在 lru 链表的头部。













#### [mysql预读](https://www.jianshu.com/p/3c4ad21f68b9)